<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Exam Scraper Dashboard</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        color: #333;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      .header {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 30px;
        margin-bottom: 30px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
        text-align: center;
      }

      .header h1 {
        font-size: 2.5rem;
        background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin-bottom: 10px;
      }

      .header p {
        color: #666;
        font-size: 1.1rem;
      }

      .dashboard-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
        margin-bottom: 30px;
      }

      .card {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
        transition: transform 0.3s ease;
      }

      .card:hover {
        transform: translateY(-5px);
      }

      .card h2 {
        color: #2c3e50;
        margin-bottom: 20px;
        font-size: 1.5rem;
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }

      .stat-card {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 15px;
        padding: 20px;
        text-align: center;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
        transition: transform 0.3s ease;
      }

      .stat-card:hover {
        transform: translateY(-5px);
      }

      .stat-number {
        font-size: 2rem;
        font-weight: 700;
        color: #4facfe;
        margin-bottom: 5px;
      }

      .stat-label {
        color: #666;
        font-size: 0.9rem;
      }

      .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 10px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-right: 10px;
        margin-bottom: 10px;
        position: relative;
        overflow: hidden;
      }

      .btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        transition: left 0.5s;
      }

      .btn:hover::before {
        left: 100%;
      }

      .btn-primary {
        background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        color: white;
      }

      .btn-success {
        background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
        color: white;
      }

      .btn-warning {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
      }

      .btn-danger {
        background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%);
        color: white;
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
      }

      .btn:active {
        transform: translateY(0);
      }

      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      .notifications-container {
        max-height: 400px;
        overflow-y: auto;
        margin-top: 20px;
      }

      .notification-item {
        background: #f8f9fa;
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 10px;
        border-left: 4px solid #4facfe;
        transition: all 0.3s ease;
      }

      .notification-item:hover {
        transform: translateX(5px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      }

      .notification-item.jee {
        border-left-color: #ff6b6b;
      }

      .notification-item.gate {
        border-left-color: #4ecdc4;
      }

      .notification-item.jee_adv {
        border-left-color: #45b7d1;
      }

      .notification-item.upsc {
        border-left-color: #96ceb4;
      }

      .notification-title {
        font-weight: 600;
        color: #2c3e50;
        margin-bottom: 5px;
      }

      .notification-meta {
        font-size: 0.8rem;
        color: #666;
        margin-bottom: 5px;
      }

      .notification-content {
        color: #495057;
        font-size: 0.9rem;
      }

      .status-indicator {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 8px;
      }

      .status-running {
        background: #28a745;
        animation: pulse 2s infinite;
      }

      .status-stopped {
        background: #dc3545;
      }

      .status-error {
        background: #ffc107;
      }

      @keyframes pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }

      .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid #f3f3f3;
        border-top: 3px solid #4facfe;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .toast {
        position: fixed;
        top: 20px;
        right: 20px;
        background: white;
        border-radius: 10px;
        padding: 15px 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        transform: translateX(400px);
        transition: transform 0.3s ease;
        border-left: 4px solid #4facfe;
        max-width: 400px;
      }

      .toast.show {
        transform: translateX(0);
      }

      .toast.success {
        border-left-color: #28a745;
      }

      .toast.error {
        border-left-color: #dc3545;
      }

      .toast.warning {
        border-left-color: #ffc107;
      }

      .toast.info {
        border-left-color: #17a2b8;
      }

      .fade-in {
        animation: fadeIn 0.5s ease;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .websites-list {
        max-height: 300px;
        overflow-y: auto;
      }

      .website-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        border-bottom: 1px solid #eee;
      }

      .website-item:last-child {
        border-bottom: none;
      }

      .website-info {
        flex: 1;
      }

      .website-name {
        font-weight: 600;
        color: #2c3e50;
      }

      .website-url {
        font-size: 0.8rem;
        color: #666;
      }

      .website-status {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .toggle-switch {
        position: relative;
        width: 50px;
        height: 24px;
        background: #ccc;
        border-radius: 12px;
        cursor: pointer;
        transition: background 0.3s;
      }

      .toggle-switch.active {
        background: #4facfe;
      }

      .toggle-switch::after {
        content: "";
        position: absolute;
        top: 2px;
        left: 2px;
        width: 20px;
        height: 20px;
        background: white;
        border-radius: 50%;
        transition: transform 0.3s;
      }

      .toggle-switch.active::after {
        transform: translateX(26px);
      }

      .demo-section {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 30px;
        margin-bottom: 30px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
      }

      .demo-section h2 {
        color: #2c3e50;
        margin-bottom: 20px;
        font-size: 1.5rem;
      }

      .demo-iframe {
        width: 100%;
        height: 600px;
        border: none;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      }

      .progress-container {
        margin: 20px 0;
        display: none;
      }

      .progress-container.show {
        display: block;
      }

      .progress-bar {
        width: 100%;
        height: 8px;
        background: #e9ecef;
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 10px;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        border-radius: 4px;
        width: 0%;
        transition: width 0.3s ease;
        position: relative;
      }

      .progress-fill::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        background-image: linear-gradient(
          -45deg,
          rgba(255, 255, 255, 0.2) 25%,
          transparent 25%,
          transparent 50%,
          rgba(255, 255, 255, 0.2) 50%,
          rgba(255, 255, 255, 0.2) 75%,
          transparent 75%,
          transparent
        );
        background-size: 20px 20px;
        animation: progress-stripes 1s linear infinite;
      }

      @keyframes progress-stripes {
        0% {
          background-position: 0 0;
        }
        100% {
          background-position: 20px 0;
        }
      }

      .progress-text {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.9rem;
        color: #666;
      }

      .progress-status {
        font-weight: 600;
        color: #4facfe;
      }

      .progress-details {
        font-size: 0.8rem;
        color: #999;
      }

      .webhook-progress {
        background: rgba(79, 172, 254, 0.1);
        border: 1px solid rgba(79, 172, 254, 0.2);
        border-radius: 10px;
        padding: 15px;
        margin-top: 15px;
      }

      @media (max-width: 768px) {
        .dashboard-grid {
          grid-template-columns: 1fr;
        }

        .header h1 {
          font-size: 2rem;
        }

        .stats-grid {
          grid-template-columns: repeat(2, 1fr);
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üéì Exam Scraper Dashboard</h1>
        <p>Real-time monitoring and management of exam notifications</p>
      </div>

      <div class="stats-grid" id="statsGrid">
        <div class="stat-card">
          <div class="stat-number" id="totalNotifications">0</div>
          <div class="stat-label">Total Notifications</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="activeScrapers">0</div>
          <div class="stat-label">Active Scrapers</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="recentUpdates">0</div>
          <div class="stat-label">Recent Updates (24h)</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="lastScrape">--:--</div>
          <div class="stat-label">Last Scrape</div>
        </div>
      </div>

      <div class="dashboard-grid">
        <div class="card">
          <h2>üöÄ System Controls</h2>
          <div style="margin-bottom: 20px">
            <button
              class="btn btn-primary"
              onclick="runScrape()"
              id="scrapeBtn"
            >
              <span id="scrapeBtnText">üîÑ Run Scrape</span>
            </button>
            <button
              class="btn btn-success"
              onclick="initNotifications()"
              id="initBtn"
            >
              <span id="initBtnText">‚ö° Initialize</span>
            </button>
            <button
              class="btn btn-warning"
              onclick="clearNotifications()"
              id="clearBtn"
            >
              <span id="clearBtnText">üóëÔ∏è Clear</span>
            </button>
          </div>

          <div style="margin-bottom: 20px">
            <h3>Webhook Integration</h3>
            <button
              class="btn btn-info"
              onclick="sendWebhookNotifications()"
              id="webhookBtn"
            >
              <span id="webhookBtnText">üì§ Send to Bot</span>
            </button>
            <button
              class="btn btn-secondary"
              onclick="testWebhook()"
              id="testWebhookBtn"
            >
              <span id="testWebhookBtnText">üß™ Test Webhook</span>
            </button>
            <button
              class="btn btn-warning"
              onclick="clearNotificationQueue()"
              id="clearQueueBtn"
            >
              <span id="clearQueueBtnText">üóëÔ∏è Clear Queue</span>
            </button>

            <!-- Progress Bar for Webhook Operations -->
            <div
              class="webhook-progress progress-container"
              id="webhookProgress"
            >
              <div class="progress-text">
                <span class="progress-status" id="progressStatus"
                  >Preparing notifications...</span
                >
                <span class="progress-details" id="progressDetails">0/0</span>
              </div>
              <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
              </div>
            </div>
          </div>

          <div style="margin-bottom: 20px">
            <h3>Notification Queue Status</h3>
            <div id="queueStatus">
              <div style="display: flex; align-items: center; gap: 10px">
                <span class="status-indicator status-stopped"></span>
                <span>Loading queue status...</span>
              </div>
            </div>
          </div>

          <div style="margin-bottom: 20px">
            <h3>System Status</h3>
            <div id="systemStatus">
              <span class="status-indicator status-stopped"></span>
              <span>Checking...</span>
            </div>
          </div>

          <div>
            <h3>Next Scheduled Run</h3>
            <div id="nextRun">Calculating...</div>
          </div>
        </div>

        <div class="card">
          <h2>üåê Website Management</h2>
          <div class="websites-list" id="websitesList">
            <div style="text-align: center; padding: 20px; color: #666">
              <div class="loading"></div>
              <div style="margin-top: 10px">Loading websites...</div>
            </div>
          </div>
        </div>
      </div>

      <div class="demo-section">
        <h2>üìù Demo Notification System</h2>
        <p style="margin-bottom: 20px; color: #666">
          Add, edit, and manage notifications in real-time. Changes will be
          automatically detected by the scraper.
        </p>
        <iframe src="/demo" class="demo-iframe" id="demoIframe"></iframe>
      </div>

      <div class="card">
        <h2>üì¢ Recent Notifications</h2>
        <div class="notifications-container" id="notificationsContainer">
          <div style="text-align: center; padding: 40px; color: #666">
            <div style="font-size: 3rem; margin-bottom: 20px">üìù</div>
            <h3>No notifications yet</h3>
            <p>Run a scrape to see notifications</p>
          </div>
        </div>
      </div>
    </div>

    <script>
      let isScraping = false;
      let isInitializing = false;
      let isClearing = false;
      let lastNotificationCount = 0;

      // Initialize dashboard
      document.addEventListener("DOMContentLoaded", function () {
        loadSystemStatus();
        loadWebsites();
        loadRecentNotifications();
        loadStats();

        // Set up auto-refresh
        setInterval(loadSystemStatus, 30000); // Every 30 seconds
        setInterval(loadRecentNotifications, 60000); // Every minute
        setInterval(loadStats, 30000); // Every 30 seconds
        setInterval(loadQueueStatus, 10000); // Every 10 seconds

        // Set up real-time notification streaming
        setupNotificationStream();
      });

      // Load system status
      async function loadSystemStatus() {
        try {
          const response = await fetch("/status");
          const data = await response.json();

          const statusElement = document.getElementById("systemStatus");
          const nextRunElement = document.getElementById("nextRun");

          if (data.status === "running") {
            statusElement.innerHTML =
              '<span class="status-indicator status-running"></span><span>System Running</span>';
          } else if (data.status === "error") {
            statusElement.innerHTML =
              '<span class="status-indicator status-error"></span><span>System Error</span>';
          } else {
            statusElement.innerHTML =
              '<span class="status-indicator status-stopped"></span><span>System Stopped</span>';
          }

          if (data.next_scheduled_run) {
            const nextRun = new Date(data.next_scheduled_run);
            nextRunElement.textContent = nextRun.toLocaleString();
          } else {
            nextRunElement.textContent = "Not scheduled";
          }
        } catch (error) {
          console.error("Error loading system status:", error);
          document.getElementById("systemStatus").innerHTML =
            '<span class="status-indicator status-error"></span><span>Connection Error</span>';
        }
      }

      // Load websites
      async function loadWebsites() {
        try {
          const response = await fetch("/websites");
          const websites = await response.json();

          const container = document.getElementById("websitesList");

          if (websites.length === 0) {
            container.innerHTML =
              '<div style="text-align: center; padding: 20px; color: #666;">No websites configured</div>';
            return;
          }

          container.innerHTML = websites
            .map(
              (website) => `
                    <div class="website-item">
                        <div class="website-info">
                            <div class="website-name">${website.name}</div>
                            <div class="website-url">${website.url}</div>
                        </div>
                        <div class="website-status">
                            <span style="font-size: 0.8rem; color: #666;">${
                              website.priority
                            }</span>
                            <div class="toggle-switch ${
                              website.enabled ? "active" : ""
                            }" 
                                 onclick="toggleWebsite('${
                                   website.name
                                 }', ${!website.enabled})">
                            </div>
                        </div>
                    </div>
                `
            )
            .join("");
        } catch (error) {
          console.error("Error loading websites:", error);
          document.getElementById("websitesList").innerHTML =
            '<div style="text-align: center; padding: 20px; color: #dc3545;">Error loading websites</div>';
        }
      }

      // Toggle website
      async function toggleWebsite(name, enabled) {
        try {
          const response = await fetch(`/websites/${name}/toggle`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ enabled }),
          });

          const result = await response.json();

          if (result.success) {
            showToast(
              `${name} ${enabled ? "enabled" : "disabled"} successfully`,
              "success"
            );
            loadWebsites(); // Reload the list
          } else {
            showToast(`Failed to toggle ${name}`, "error");
          }
        } catch (error) {
          console.error("Error toggling website:", error);
          showToast("Error toggling website", "error");
        }
      }

      // Load recent notifications
      async function loadRecentNotifications() {
        try {
          const response = await fetch("/recent_updates/24");
          const notifications = await response.json();

          const container = document.getElementById("notificationsContainer");

          if (notifications.length === 0) {
            container.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #666;">
                            <div style="font-size: 3rem; margin-bottom: 20px;">üìù</div>
                            <h3>No notifications yet</h3>
                            <p>Run a scrape to see notifications</p>
                        </div>
                    `;
            return;
          }

          container.innerHTML = notifications
            .slice(0, 10)
            .map(
              (notification) => `
                    <div class="notification-item ${
                      notification.exam_type || "jee"
                    } fade-in">
                        <div class="notification-title">${
                          notification.title
                        }</div>
                        <div class="notification-meta">
                            ${notification.source} ‚Ä¢ ${
                notification.exam_type || "N/A"
              } ‚Ä¢ ${formatDate(notification.scraped_at)}
                        </div>
                        <div class="notification-content">${
                          notification.content_summary || notification.title
                        }</div>
                    </div>
                `
            )
            .join("");

          // Check for new notifications
          if (
            notifications.length > lastNotificationCount &&
            lastNotificationCount > 0
          ) {
            const newCount = notifications.length - lastNotificationCount;
            showToast(
              `${newCount} new notification${newCount > 1 ? "s" : ""} found!`,
              "success"
            );
          }

          lastNotificationCount = notifications.length;
        } catch (error) {
          console.error("Error loading notifications:", error);
        }
      }

      // Load stats
      async function loadStats() {
        try {
          const response = await fetch("/status");
          const data = await response.json();

          document.getElementById("totalNotifications").textContent =
            data.recent_updates_24h || 0;
          document.getElementById("activeScrapers").textContent =
            data.total_scrapers || 0;
          document.getElementById("recentUpdates").textContent =
            data.recent_updates_24h || 0;

          if (data.last_scrape) {
            const lastScrape = new Date(data.last_scrape);
            document.getElementById("lastScrape").textContent =
              lastScrape.toLocaleTimeString();
          }
        } catch (error) {
          console.error("Error loading stats:", error);
        }
      }

      // Load queue status
      async function loadQueueStatus() {
        try {
          const response = await fetch("/notifications/queue/status");
          const data = await response.json();

          if (data.success) {
            const queueStatus = data.queue_status;
            const statusElement = document.getElementById("queueStatus");
            const progressContainer =
              document.getElementById("webhookProgress");

            const totalPending = queueStatus.status_counts?.pending || 0;
            const totalSending = queueStatus.status_counts?.sending || 0;
            const totalSent = queueStatus.status_counts?.sent || 0;
            const totalFailed = queueStatus.status_counts?.failed || 0;
            const totalRetry = queueStatus.status_counts?.retry || 0;
            const totalProcessing = totalPending + totalSending + totalRetry;
            const totalCompleted = totalSent + totalFailed;

            let statusText = "";
            let statusClass = "status-stopped";

            if (totalPending > 0 || totalSending > 0 || totalRetry > 0) {
              statusClass = "status-running";
              statusText = `Processing: ${totalPending} pending, ${totalSending} sending, ${totalRetry} retry`;

              // Show progress bar if there are active notifications being processed
              if (!progressContainer.classList.contains("show")) {
                progressContainer.classList.add("show");
                const total = totalProcessing + totalCompleted;
                const percentage =
                  totalCompleted > 0
                    ? Math.round((totalCompleted / total) * 100)
                    : 0;
                updateProgress(
                  percentage,
                  "Processing notifications...",
                  `${totalCompleted}/${total}`
                );
              }
            } else if (totalSent > 0) {
              statusClass = "status-running";
              statusText = `Completed: ${totalSent} sent`;

              // Hide progress bar if processing is complete
              if (progressContainer.classList.contains("show")) {
                setTimeout(() => {
                  progressContainer.classList.remove("show");
                  updateProgress(0, "Preparing notifications...", "0/0");
                }, 2000);
              }
            } else if (totalFailed > 0) {
              statusClass = "status-error";
              statusText = `Failed: ${totalFailed} failed`;
            } else {
              statusText = "Queue empty";

              // Hide progress bar if queue is empty
              if (progressContainer.classList.contains("show")) {
                progressContainer.classList.remove("show");
                updateProgress(0, "Preparing notifications...", "0/0");
              }
            }

            statusElement.innerHTML = `
              <div style="display: flex; align-items: center; gap: 10px;">
                <span class="status-indicator ${statusClass}"></span>
                <span>${statusText}</span>
              </div>
              <div style="font-size: 0.8rem; color: #666; margin-top: 5px;">
                Queue size: ${queueStatus.queue_size || 0} | 
                Processing: ${queueStatus.processing ? "Yes" : "No"}
              </div>
            `;
          }
        } catch (error) {
          console.error("Error loading queue status:", error);
          document.getElementById("queueStatus").innerHTML = `
            <div style="display: flex; align-items: center; gap: 10px;">
              <span class="status-indicator status-error"></span>
              <span>Error loading queue status</span>
            </div>
          `;
        }
      }

      // Run scrape
      async function runScrape() {
        if (isScraping) return;

        isScraping = true;
        const btn = document.getElementById("scrapeBtn");
        const btnText = document.getElementById("scrapeBtnText");

        btn.disabled = true;
        btnText.innerHTML = '<div class="loading"></div> Running...';

        try {
          const response = await fetch("/scrape", { method: "POST" });
          const result = await response.json();

          if (result.new_updates_count > 0) {
            showToast(
              `Found ${result.new_updates_count} new updates!`,
              "success"
            );
          } else {
            showToast("No new updates found", "info");
          }

          // Refresh data
          loadRecentNotifications();
          loadStats();
        } catch (error) {
          console.error("Error running scrape:", error);
          showToast("Error running scrape", "error");
        } finally {
          isScraping = false;
          btn.disabled = false;
          btnText.innerHTML = "üîÑ Run Scrape";
        }
      }

      // Initialize notifications
      async function initNotifications() {
        if (isInitializing) return;

        isInitializing = true;
        const btn = document.getElementById("initBtn");
        const btnText = document.getElementById("initBtnText");

        btn.disabled = true;
        btnText.innerHTML = '<div class="loading"></div> Initializing...';

        try {
          const response = await fetch("/notifications/init", {
            method: "POST",
          });
          const result = await response.json();

          if (result.success) {
            showToast("Notifications initialized successfully!", "success");
          } else {
            showToast("Failed to initialize notifications", "error");
          }

          // Refresh data
          loadRecentNotifications();
          loadStats();
        } catch (error) {
          console.error("Error initializing notifications:", error);
          showToast("Error initializing notifications", "error");
        } finally {
          isInitializing = false;
          btn.disabled = false;
          btnText.innerHTML = "‚ö° Initialize";
        }
      }

      // Clear notifications
      async function clearNotifications() {
        if (isClearing) return;

        if (!confirm("Are you sure you want to clear all notifications?")) {
          return;
        }

        isClearing = true;
        const btn = document.getElementById("clearBtn");
        const btnText = document.getElementById("clearBtnText");

        btn.disabled = true;
        btnText.innerHTML = '<div class="loading"></div> Clearing...';

        try {
          const response = await fetch("/notifications/clear", {
            method: "POST",
          });
          const result = await response.json();

          if (result.success) {
            showToast("Notifications cleared successfully!", "success");
          } else {
            showToast("Failed to clear notifications", "error");
          }

          // Refresh data
          loadRecentNotifications();
          loadStats();
        } catch (error) {
          console.error("Error clearing notifications:", error);
          showToast("Error clearing notifications", "error");
        } finally {
          isClearing = false;
          btn.disabled = false;
          btnText.innerHTML = "üóëÔ∏è Clear";
        }
      }

      // Show toast notification
      function showToast(message, type = "info") {
        const toast = document.createElement("div");
        toast.className = `toast ${type}`;
        toast.innerHTML = `
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span>${getToastIcon(type)}</span>
                    <span>${message}</span>
                </div>
            `;

        document.body.appendChild(toast);

        setTimeout(() => toast.classList.add("show"), 100);
        setTimeout(() => {
          toast.classList.remove("show");
          setTimeout(() => document.body.removeChild(toast), 300);
        }, 4000);
      }

      // Get toast icon based on type
      function getToastIcon(type) {
        const icons = {
          success: "‚úÖ",
          error: "‚ùå",
          warning: "‚ö†Ô∏è",
          info: "‚ÑπÔ∏è",
        };
        return icons[type] || icons.info;
      }

      // Format date
      function formatDate(dateString) {
        return new Date(dateString).toLocaleDateString("en-US", {
          month: "short",
          day: "numeric",
          hour: "2-digit",
          minute: "2-digit",
        });
      }

      // Update progress bar
      function updateProgress(percentage, status, details) {
        const progressFill = document.getElementById("progressFill");
        const progressStatus = document.getElementById("progressStatus");
        const progressDetails = document.getElementById("progressDetails");

        if (progressFill) {
          progressFill.style.width = `${percentage}%`;
        }
        if (progressStatus) {
          progressStatus.textContent = status;
        }
        if (progressDetails) {
          progressDetails.textContent = details;
        }
      }

      // Send notifications to webhook
      async function sendWebhookNotifications() {
        const webhookBtn = document.getElementById("webhookBtn");
        const webhookBtnText = document.getElementById("webhookBtnText");
        const progressContainer = document.getElementById("webhookProgress");
        const progressStatus = document.getElementById("progressStatus");
        const progressDetails = document.getElementById("progressDetails");
        const progressFill = document.getElementById("progressFill");

        // Disable button and show loading
        webhookBtn.disabled = true;
        webhookBtnText.textContent = "üì§ Sending...";

        // Show progress bar
        progressContainer.classList.add("show");
        updateProgress(0, "Preparing notifications...", "0/0");

        try {
          // Simulate progress for better UX
          updateProgress(20, "Fetching notifications...", "0/0");
          await new Promise((resolve) => setTimeout(resolve, 500));

          updateProgress(40, "Adding to webhook queue...", "0/0");
          await new Promise((resolve) => setTimeout(resolve, 500));

          const response = await fetch("/notifications/send-webhook", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
          });

          updateProgress(60, "Sending to bot...", "0/0");
          await new Promise((resolve) => setTimeout(resolve, 500));

          const result = await response.json();

          updateProgress(80, "Processing response...", "0/0");
          await new Promise((resolve) => setTimeout(resolve, 300));

          if (result.success) {
            updateProgress(
              100,
              "‚úÖ Completed successfully!",
              `${result.notifications_sent || 0} notifications sent`
            );

            showToast(
              `‚úÖ ${result.message} (${result.notifications_sent} notifications sent)`,
              "success"
            );

            // Show webhook results if available
            if (result.webhook_results) {
              const webhookResults = result.webhook_results;
              if (webhookResults.successful > 0) {
                showToast(
                  `ü§ñ Bot delivered to ${webhookResults.successful} subscribers`,
                  "success"
                );
              }
              if (webhookResults.failed > 0) {
                showToast(
                  `‚ö†Ô∏è ${webhookResults.failed} notifications failed to deliver`,
                  "warning"
                );
              }
            }
          } else {
            updateProgress(100, "‚ùå Failed", "Error occurred");
            showToast(
              `‚ùå Webhook failed: ${result.error || result.message}`,
              "error"
            );
          }
        } catch (error) {
          console.error("Error sending webhook notifications:", error);
          updateProgress(100, "‚ùå Error", "Connection failed");
          showToast("Error sending webhook notifications", "error");
        } finally {
          // Re-enable button and hide progress after delay
          webhookBtn.disabled = false;
          webhookBtnText.textContent = "üì§ Send to Bot";

          // Hide progress bar after 3 seconds
          setTimeout(() => {
            progressContainer.classList.remove("show");
            updateProgress(0, "Preparing notifications...", "0/0");
          }, 3000);
        }
      }

      // Test webhook connectivity
      async function testWebhook() {
        const testBtn = document.getElementById("testWebhookBtn");
        const testBtnText = document.getElementById("testWebhookBtnText");
        const progressContainer = document.getElementById("webhookProgress");

        // Disable button and show loading
        testBtn.disabled = true;
        testBtnText.textContent = "üß™ Testing...";

        // Show progress bar
        progressContainer.classList.add("show");
        updateProgress(0, "Testing webhook connection...", "0/0");

        try {
          updateProgress(30, "Connecting to bot...", "0/0");
          await new Promise((resolve) => setTimeout(resolve, 300));

          const response = await fetch("/webhook/test", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
          });

          updateProgress(70, "Processing response...", "0/0");
          await new Promise((resolve) => setTimeout(resolve, 300));

          const result = await response.json();

          if (result.success) {
            updateProgress(100, "‚úÖ Test successful!", "Bot is reachable");
            showToast(
              "‚úÖ Webhook test successful! Bot is reachable.",
              "success"
            );

            // Show webhook response details
            if (result.webhook_response) {
              const webhookResp = result.webhook_response;
              if (webhookResp.totalSubscribers) {
                showToast(
                  `ü§ñ Bot has ${webhookResp.totalSubscribers} subscribers`,
                  "info"
                );
              }
            }
          } else {
            updateProgress(100, "‚ùå Test failed", "Connection error");
            showToast(
              `‚ùå Webhook test failed: ${result.error || result.message}`,
              "error"
            );
          }
        } catch (error) {
          console.error("Error testing webhook:", error);
          updateProgress(100, "‚ùå Error", "Connection failed");
          showToast("Error testing webhook", "error");
        } finally {
          // Re-enable button and hide progress after delay
          testBtn.disabled = false;
          testBtnText.textContent = "üß™ Test Webhook";

          // Hide progress bar after 3 seconds
          setTimeout(() => {
            progressContainer.classList.remove("show");
            updateProgress(0, "Preparing notifications...", "0/0");
          }, 3000);
        }
      }

      // Clear notification queue
      async function clearNotificationQueue() {
        if (
          !confirm(
            "Are you sure you want to clear the notification queue? This will remove all pending webhook notifications."
          )
        ) {
          return;
        }

        const clearBtn = document.getElementById("clearQueueBtn");
        const clearBtnText = document.getElementById("clearQueueBtnText");

        // Disable button and show loading
        clearBtn.disabled = true;
        clearBtnText.textContent = "üóëÔ∏è Clearing...";

        try {
          const response = await fetch("/notifications/queue/clear", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
          });

          const result = await response.json();

          if (result.success) {
            showToast("‚úÖ Notification queue cleared successfully!", "success");
            // Refresh queue status
            loadQueueStatus();
          } else {
            showToast(`‚ùå Failed to clear queue: ${result.error}`, "error");
          }
        } catch (error) {
          console.error("Error clearing queue:", error);
          showToast("Error clearing notification queue", "error");
        } finally {
          // Re-enable button
          clearBtn.disabled = false;
          clearBtnText.textContent = "üóëÔ∏è Clear Queue";
        }
      }

      // Set up real-time notification streaming
      function setupNotificationStream() {
        if (typeof EventSource !== "undefined") {
          const eventSource = new EventSource("/notifications/stream");

          eventSource.onmessage = function (event) {
            try {
              const data = JSON.parse(event.data);

              if (data.type === "new_notifications") {
                showToast(
                  `üéâ ${data.count} new notification${
                    data.count > 1 ? "s" : ""
                  } found!`,
                  "success"
                );

                // Refresh notifications and stats
                loadRecentNotifications();
                loadStats();
              } else if (data.type === "heartbeat") {
                // Connection is alive
                console.log("Notification stream heartbeat:", data.timestamp);
              } else if (data.type === "error") {
                console.error("Notification stream error:", data.error);
                showToast("Notification stream error", "error");
              }
            } catch (error) {
              console.error("Error parsing notification stream data:", error);
            }
          };

          eventSource.onerror = function (event) {
            console.error("Notification stream error:", event);
            showToast("Lost connection to notification stream", "warning");
          };

          eventSource.onopen = function (event) {
            console.log("Notification stream connected");
            showToast("Real-time notifications enabled", "info");
          };
        } else {
          console.warn("EventSource not supported, falling back to polling");
          showToast(
            "Real-time notifications not supported in this browser",
            "warning"
          );
        }
      }

      // Real-time queue progress streaming
      (function setupQueueProgressStream() {
        if (typeof EventSource === "undefined") return;

        const progressContainer = document.getElementById("webhookProgress");

        function computeProgress(counts) {
          const totalCompleted = (counts.sent || 0) + (counts.failed || 0);
          const totalProcessing =
            (counts.pending || 0) + (counts.sending || 0) + (counts.retry || 0);
          const total = totalCompleted + totalProcessing;
          const percentage =
            total > 0 ? Math.round((totalCompleted / total) * 100) : 0;
          return { percentage, totalCompleted, total };
        }

        function applyProgressFromStatus(queueStatus) {
          const counts = queueStatus.status_counts || {};
          const metrics = queueStatus.metrics || {};
          const calc = computeProgress(counts);
          const percentage =
            typeof metrics.progress_percent === "number"
              ? metrics.progress_percent
              : calc.percentage;
          const totalCompleted =
            typeof metrics.total_completed === "number"
              ? metrics.total_completed
              : calc.totalCompleted;
          const total =
            typeof metrics.total_added === "number" && metrics.total_added > 0
              ? metrics.total_added
              : calc.total;

          if ((counts.pending || counts.sending || counts.retry) > 0) {
            if (!progressContainer.classList.contains("show")) {
              progressContainer.classList.add("show");
            }
            updateProgress(
              percentage,
              "Processing notifications...",
              `${totalCompleted}/${total}`
            );
          } else if ((counts.sent || 0) > 0) {
            const completed =
              typeof metrics.total_completed === "number"
                ? metrics.total_completed
                : (counts.sent || 0) + (counts.failed || 0);
            updateProgress(100, "‚úÖ Completed", `${completed}/${completed}`);
            setTimeout(() => {
              progressContainer.classList.remove("show");
              updateProgress(0, "Preparing notifications...", "0/0");
            }, 2000);
          } else {
            // nothing in queue
            if (progressContainer.classList.contains("show")) {
              progressContainer.classList.remove("show");
            }
            updateProgress(0, "Preparing notifications...", "0/0");
          }
        }

        const qs = new EventSource("/notifications/queue/stream");
        qs.onmessage = function (event) {
          try {
            const data = JSON.parse(event.data);
            if (data.type === "queue_status" && data.queue_status) {
              const qs = data.queue_status;
              applyProgressFromStatus(qs);

              // Update status card with real-time data
              const statusElement = document.getElementById("queueStatus");
              const counts = qs.status_counts || {};
              const m = qs.metrics || {};
              const pending = counts.pending || 0;
              const sending = counts.sending || 0;
              const retry = counts.retry || 0;
              const sent = counts.sent || 0;
              const failed = counts.failed || 0;

              let statusText = "Queue empty";
              let statusClass = "status-stopped";
              if (pending > 0 || sending > 0 || retry > 0) {
                statusClass = "status-running";
                statusText = `Processing: ${pending} pending, ${sending} sending, ${retry} retry`;
              } else if (sent > 0) {
                statusClass = "status-running";
                statusText = `Completed: ${sent} sent`;
              } else if (failed > 0) {
                statusClass = "status-error";
                statusText = `Failed: ${failed} failed`;
              }

              statusElement.innerHTML = `
                <div style="display: flex; align-items: center; gap: 10px;">
                  <span class="status-indicator ${statusClass}"></span>
                  <span>${statusText}</span>
                </div>
                <div style="font-size: 0.8rem; color: #666; margin-top: 5px;">
                  Queue size: ${qs.queue_size || 0} | Processing: ${
                qs.processing ? "Yes" : "No"
              } | Added: ${m.total_added || 0} | Sent: ${
                m.total_sent || 0
              } | Failed: ${m.total_failed || 0}
                </div>
              `;

              const fill = document.getElementById("progressFill");
              if (fill) {
                fill.title = `Added: ${m.total_added || 0}, Sent: ${
                  m.total_sent || 0
                }, Failed: ${m.total_failed || 0}, Retried: ${
                  m.total_retried || 0
                }`;
              }
            }
          } catch (e) {
            console.error("Queue stream parse error", e);
          }
        };
        qs.onerror = function (event) {
          console.warn("Queue status stream error", event);
        };
      })();
    </script>
  </body>
</html>
